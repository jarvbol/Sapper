#include <iostream>  
#include <string>
#include <cmath>
#include <array>
#include <cstdlib>
#include <ctime>
#include <fstream>

int field[100][100]; /* Создается массив размером 100х100 с обозначениями о количестве мин
 "-1" это мина,"0-8" числа сообщающие о количестве мин рядом. Такой большой массив создан, чтобы при желаниии
можно было увеличить размер игрового поля */
int field_p[100][100]; /* Создается массив состояний размером 100х100 (Состояние клетки : закрыта, открыта, стоит флаг)
"-2" - клетка закрыта, "-1" - над клеткой стоит флаг, "0-8" - клетка открыта*/
const int N = 9, M = 9, K = 10; // Констатнты на основании которых создается игровое поле.


void print_field() // Вывод поля на консоль.
{
	system("cls");// Очистка консоли, модуль system позволяет принимать специальные команды с консоли
	std::cout << "  ";
	for (int i = 0; i < M; ++i)// Вывод верхней строки с координатами для игры.
	{
		std::cout << " " << i + 1;
		if (i + 1 < 10) std::cout << ' ';
	}
	std::cout << '\n';
	for (int i = 0; i < N; i++) /* Заполнение оставшихся строк : 1 столбец - цифры, последующие информацие о наличие мины над ним.*/
	{

		std::cout << i + 1 << " ";
		if (i + 1 < 10) std::cout << ' ';

		for (int j = 0; j < M; j++) {
			if (field_p[i][j] == -2) std::cout << "_  "; // Клетка закрыта.
			else if (field_p[i][j] == -1) std::cout << "f  "; // Мина над которой стоит флаг.
			else if (field_p[i][j] == -3) std::cout << "*  ";// Пользователь наткнулся на мину, показ мины на поле.
			else std::cout << field_p[i][j] << "  "; // Заполнение символом пробел.
		}
		std::cout << '\n';
	}
	std::cout << '\n' << '\n' << '\n';
}


void dfs(int x, int y) {
	if (x < 0 || x >= N || y < 0 || y >= M || field_p[x][y] > -2) return; /* Проверка введенных пользователем
	данных на корректность*/
	field_p[x][y] = field[x][y];
	if (field[x][y] > 0) return;// Если все данные корректны, идем дальше по программе.
	for (int i2 = x - 1; i2 <= x + 1; ++i2) { // Проход по значениям х.
		for (int j2 = y - 1; j2 <= y + 1; ++j2) { // Проход по значениям у.
			if (i2 != x || j2 != y) dfs(i2, j2);// Проверка корректности с использованием рекурсии.
		}
	}
}


bool open_cell(int x, int y) // х и у это координаты, которые передает пользователь.
{
	if (field[x][y] == -1) return false; // Проверяем ячейку с заданными координатами на наличие мины.
	if (field[x][y] > 0) { /* Если в ячейке отсутсвует бомба, мы передаем значения из массива о наличии мин
		в массив состояний клеток.*/
		field_p[x][y] = field[x][y];
		return true;
	}
	dfs(x, y);
}


bool is_win() { // Функция операнд, выражающая состояние в игре.
	int opened = 0;
	for (int i = 0; i < N; i++) { // Проход по значениям i.
		for (int j = 0; j < M; j++) { // Проход по значениям j.
			if (field_p[i][j] >= 0) opened++; //0 1 2 3 
		}/* Если значения i и j в массиве состояния клеток не меньше нуля ( 0,1,2,3, ...) продолжаем
		 увеличивать значения "opened", иначе мы переходим к следующей итерации цикла.*/
	}
	return (N * M - K == opened); // Возвращает логическое значение, полученное в функции.
}



void end_game(bool is_win = false) //
{
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			if (field_p[i][j] == -1) field_p[i][j] = -2; // В массив состояний передаем значение о том, что ячейка закрыта.
			if (field[i][j] == -1) field_p[i][j] = -3; /* Если в массиве о количестве мин есть в данной ячейке мина
			то в массив состояний эта информация так же записывается.*/
		}
	}
	print_field();// Печать поля после каждого открытия ячейки.
	//В зависимости от результата у нас на экране появится надпись.
	std::cout << "You " << (is_win ? "win" : "lost") << ",\nwanna start new game?:\n";/* Завершение игры с результатами:
	"Победа" или "Поражение" в зависимости от итоговых значений, переданных в  функцию "is_win".*/
	std::string s;
	std::cin >> s;
}

int main()
{
	while (true) //Если открыли клетку без мины, выполняется следующий блок кода:
	{
		std::srand(std::time(0)); //Расстановка мин изменяется ежесекундно (ГПСЧ). 
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++) {
				field[i][j] = 0; // Заполнение массива "пустотой" (отсутствие мин).
				field_p[i][j] = -2; // Заполнение массива "закрытыми ячейками".
			}
		}
		for (int i = 0; i < K; ++i) { // Количество мин, расположенных на поле.
			while (true) {
				int x = std::rand() % N; // Координата мины по х.
				int y = std::rand() % M; // Координата мины по у.
				if (field[x][y] != -1) // "Случайным" образом разбрасываем по полю мины, если в этой клетке еще нет мины.
				{
					field[x][y] = -1;
					break;
				}
			}
		}
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) { // Проход по полю.
				if (field[i][j] != -1) { // Если мина не стоит в данной ячейке, то ячейке присваивается значение "0" - отсутствие мин.
					field[i][j] = 0;
					for (int i2 = i - 1; i2 <= i + 1; ++i2) {
						for (int j2 = j - 1; j2 <= j + 1; ++j2) {
							if (i2 >= 0 && i2 < N && j2 >= 0 && j2 <= M && field[i2][j2] == -1)  ++field[i][j];
							// В массиве состояния мин смотрим совпадение на мину и будет осуществляться переход на следующую ячейку.

						}
					}
				}
			}
		}
		while (true) {
			print_field(); // Печать поля.
			std::cout << "Rules of the game.\nThe user enters the command and the coordinates of the intended mine separated by a space.\n\n" << "Commands used in the game:\n\n";
			std::cout << "  open - opening the cell.\n" << "  flag - setting a flag over a suspected mine.\n" << "  new- start of a new game.\n" << "  exit- the end of the game.\n\n";
			std::cout << "Enter comand:";

			std::string comand;
			std::cin >> comand;
			if (comand == "\\open") {
				// При указании команды "открыть" задаем возможность выбора координат, т.е. клеточки, которую хотим открыть. 
				int x, y;
				std::cin >> x >> y;
				--x; --y;
				// Открываем клетки.
				if (x < 0 || x >= N || y < 0 || y >= M || field_p[x][y] >= 0) continue;
				if (!open_cell(x, y)) { // Проверяем открыта-ли клетка.
					end_game();
					break;
				}
				if (is_win()) { // Проверка на удачное открытие клетки.
					end_game(true);
					break;
				}
			}
			else if (comand == "\\flaf") {
				// Вводим координаты.
				int x, y;
				std::cin >> x >> y;
				--x; --y;
				if (x < 0 || x >= N || y < 0 || y >= M || field_p[x][y] >= 0) continue;
				// Ставим флаг.
				if (field_p[x][y] == -1) field_p[x][y] = -2;
				else field_p[x][y] = -1;
			}
			else if (comand == "\\new") { // Создается новая игра.
				break;
			}
			else if (comand == "\\exit") { // Производится выход из игры.
				return 0;
			}
		}
	}
}

